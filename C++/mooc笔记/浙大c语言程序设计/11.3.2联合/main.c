//
//  main.c
//  11.3.2联合
//
//  Created by 张亮 on 2020/1/30.
//  Copyright © 2020 张亮. All rights reserved.
//

#include <stdio.h>
void 大小端测试(void);
union data{
    int n;
    char ch;
    short m;
};
int main(){
    union data a;
    printf("%d, %d\n", sizeof(a), sizeof(union data) );
    a.n = 0x40;
    printf("%X, %c, %hX\n", a.n, a.ch, a.m);
    a.ch = '9';
    printf("%X, %c, %hX\n", a.n, a.ch, a.m);
    a.m = 0x2059;
    printf("%X, %c, %hX\n", a.n, a.ch, a.m);
    a.n = 0x3E25AD54;
    printf("%X, %c, %hX\n", a.n, a.ch, a.m);
    大小端测试();
    return 0;
}
//详见http://c.biancheng.net/view/2035.html
/*
 当一个数据在内存中占多个字节时，才会考虑大小端。内存地址是以字节为单位的，如果一个数据只占一个字节，比如char型的字符，那这个字节的内存中就保存字符对应的ascii码值。如果int型的整数占四个字节，那这四个字节分别保存这个整数的哪些部分呢，这就涉及到大小端了。（此外一个int数组中各个元素的地址是递增四个字节的，不要和每个元素内部怎么占用这四个字节的混淆。）

 所谓的大端模式(Big-endian)，是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理:地址由小向大增加，而数据从高位往低位放;
 所谓的小端模式(Little-endian)，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。

 为什么会有大小端模式之分呢?这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型(要看具体的编译器)，另外，对于位数大于 8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于 大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以随时在程序中(在ARM Cortex 系列使用REV、REV16、REVSH指令 )进行大小端的切换。

 在几乎所有的机器上，多字节对象都被存储为连续的字节序列。
 例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。

 大端字节序：在内存中，低地址存放数据的高位，高地址存放数据的低位
 小端字节序：在内存中，低地址存放数据的低位，高地址存放数据的高位

 假设变量x类型为int，位于地址0x100处，它的十六进制为0x01234567，地址范围为0x100~0x103字节，其内部排列顺序依赖于机器的类型。
 大端法从首位开始是：0x100: 01, 0x101: 23, 0x102: 45, 0x103: 67
 小端法从首位开始是：0x100: 67, 0x101: 45, 0x102: 23, 0x103: 01
 *///大小端测试:
union {
    int i;
    char ch[sizeof(int)];
} Beta;
void 大小端测试(void)
{
    Beta.i=1234;//对应储存在4个字节内存中为00 00 04 D2
    for (int i=0; i<sizeof(int); i++)
    {
        printf("%02hhx ",Beta.ch[i]);
    }
    printf("\n%s结果为小端机器,低位在前\n",__func__);//__func__表示当前函数的名字
    //一般来说,只有单片机是大端机器
}
